package cc.unknown.module.impl.exploit;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicReference;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.network.DisconnectionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.ModeValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.network.PacketUtil;
import cc.unknown.utils.network.TimedPacket;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.server.S03PacketTimeUpdate;

@Register(name = "FakeLag", category = Category.Exploit)
public class FakeLag extends Module {

	private Queue<TimedPacket> inboundPackets = new ConcurrentLinkedQueue<>();
	private Queue<TimedPacket> outboundPackets = new ConcurrentLinkedQueue<>();

	private ModeValue mode = new ModeValue("Mode", "Inbound", "Inbound", "Outbound", "Both");
	private SliderValue inboundDelay = new SliderValue("Inbound Delay", 500, 0, 1000, 10);
	private SliderValue outboundDelay = new SliderValue("Outbound Delay", 500, 0, 1000, 10);

	public FakeLag() {
		this.registerSetting(mode, inboundDelay, outboundDelay);
	}

	@EventLink
	public void onGui(ClickGuiEvent e) {
		AtomicReference<String> suffixRef = new AtomicReference<>();

		if (mode.is("Inbound")) {
			suffixRef.set("- [" + inboundDelay.getInputToInt() + " ms]");
		} else if (mode.is("Outbound")) {
			suffixRef.set("- [" + outboundDelay.getInputToInt() + " ms]");
		} else if (mode.is("Both")) {
			suffixRef.set("- [" + inboundDelay.getInputToInt() + " | " + outboundDelay.getInputToInt() + " ms]");
		}

		this.setSuffix(suffixRef.get());
	}


	@Override
	public void onEnable() {
		super.onEnable();
		if (mc.thePlayer == null || mc.isIntegratedServerRunning()) {
			toggle();
			return;
		}
		clearPackets();
	}

	@Override
	public void onDisable() {
		super.onDisable();

		if (mc.thePlayer == null)
			return;

		if (mc.thePlayer != null && !inboundPackets.isEmpty())
			inboundPackets.forEach(p -> {
				PacketUtil.receivePacketNoEvent((Packet<INetHandler>) p.getPacket());
			});
		inboundPackets.clear();

		if (mc.thePlayer != null && !outboundPackets.isEmpty())
			outboundPackets.forEach(p -> {
				PacketUtil.sendPacketNoEvent(p.getPacket());
			});
		outboundPackets.clear();

	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (mc.thePlayer == null || mc.thePlayer.isDead)
			return;

		if (e.getPacket() instanceof S03PacketTimeUpdate) {
			return;
		}

		if (e.isReceive() && mode.is("Inbound") || mode.is("Both")) {
			inboundPackets.add(new TimedPacket(e.getPacket()));
			e.setCancelled(true);

			while (!inboundPackets.isEmpty()) {
				if (inboundPackets.peek().getCold().getCum(inboundDelay.getInputToInt())) {
					Packet<?> p = inboundPackets.poll().getPacket();
					PacketUtil.receivePacketNoEvent(p);
				} else {
					break;
				}
			}
		}

		if (e.isSend() && mode.is("Outbound") || mode.is("Both")) {
			outboundPackets.add(new TimedPacket(e.getPacket()));
			e.setCancelled(true);

			while (!outboundPackets.isEmpty()) {
				if (outboundPackets.peek().getCold().getCum(outboundDelay.getInputToInt())) {
					Packet<?> p = outboundPackets.poll().getPacket();
					PacketUtil.sendPacketNoEvent(p);
				} else {
					break;
				}
			}
		}
	}

	@EventLink
	public void onDisconnect(final DisconnectionEvent e) {
		this.disable();
	}

	private void clearPackets() {
		this.outboundPackets.clear();
		this.inboundPackets.clear();
	}

}
