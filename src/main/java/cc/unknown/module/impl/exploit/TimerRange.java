package cc.unknown.module.impl.exploit;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.PreMotionEvent;
import cc.unknown.event.impl.netty.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.DoubleSliderValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.player.CombatUtil;
import cc.unknown.utils.player.MoveUtil;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.server.S12PacketEntityVelocity;
import net.minecraft.util.MathHelper;

@Register(name = "TimerRange", category = Category.Exploit)
public class TimerRange extends Module {

	private SliderValue range = new SliderValue("Range", 3.5f, 1f, 5f, 0.05);
	private SliderValue positiveTimer = new SliderValue("Positive Timer", 1.5f, 0.01f, 35f, 0.01);
	private SliderValue positiveTicks = new SliderValue("Positive Ticks", 10, 1, 20, 1);

	private SliderValue negativeTimer = new SliderValue("Negative Timer", 0.45f, 0.05f, 5f, 0.05);
	private SliderValue negativeTick = new SliderValue("Negative Ticks", 10, 1, 50, 1);

	private DoubleSliderValue timerBoost = new DoubleSliderValue("Timer Boost", 0.5, 0.56, 0.1, 1, 1);
	private DoubleSliderValue timerCharged = new DoubleSliderValue("Timer Charged", 0.75, 0.91, 0.1, 1, 1);

	private BooleanValue ignoreTeams = new BooleanValue("Ignore Teams", false);
	private BooleanValue onlyGround = new BooleanValue("Only on Ground", false);
	private BooleanValue onlyForward = new BooleanValue("Only Forward", true);
	private BooleanValue notInCombo = new BooleanValue("Not In Combo", true);

	private int playerTicks = 0;
	private int cooldownTick = 0;
	private boolean confirmAttack = false;
	private boolean confirmKnockback = false;
	private EntityPlayer target;

	public TimerRange() {
		this.registerSetting(range, positiveTimer, positiveTicks, negativeTimer, negativeTick, timerBoost, timerCharged,
				ignoreTeams, onlyGround, onlyForward, notInCombo);
	}

	@EventLink
	public void onGui(ClickGuiEvent e) {
		this.setSuffix("- [" + positiveTimer.getInput() + ", " + negativeTimer.getInput() + "]");
	}

	@Override
	public void onEnable() {
		timerReset();
	}

	@Override
	public void onDisable() {
		timerReset();
		cooldownTick = 0;
		playerTicks = 0;
		confirmAttack = false;
		confirmKnockback = false;
	}

	@EventLink
	public void onWorld(ChangeWorldEvent e) {
		timerReset();
		cooldownTick = 0;
		playerTicks = 0;
		confirmAttack = false;
		confirmKnockback = false;
	}

	@EventLink
	public void onLiving(PreMotionEvent e) {
		if (target == null) {
			return;
		}

		float timerboost = cc.unknown.utils.helpers.MathUtil.randomNumber(timerBoost.getInputMinToFloat(),
				timerBoost.getInputMaxToFloat()).floatValue();
		float charged = cc.unknown.utils.helpers.MathUtil.randomNumber(timerCharged.getInputMinToFloat(),
				timerCharged.getInputMaxToFloat()).floatValue();
		double predictX = mc.thePlayer.posX + ((mc.thePlayer.posX - mc.thePlayer.lastTickPosX) * 2);
		double predictZ = mc.thePlayer.posZ + ((mc.thePlayer.posZ - mc.thePlayer.lastTickPosZ) * 2);
		float f = (float) (predictX - target.posX);
		float f1 = (float) (mc.thePlayer.posY - target.posY);
		float f2 = (float) (predictZ - target.posZ);
		double predictedDistance = MathHelper.sqrt_float(f * f + f1 * f1 + f2 * f2);

		if (playerTicks <= 0) {
			timerReset();
			return;
		}

		if (CombatUtil.instance.isTeam(target) && ignoreTeams.isToggled()) {
			timerReset();
			return;
		}

		if (mc.thePlayer.getDistance(target.posX, target.posY, target.posZ) < mc.thePlayer.getDistance(0, 0, 0)
				&& notInCombo.isToggled()) {
			timerReset();
			return;
		}

		if ((MoveUtil.getSpeed() <= 0.08 || !mc.gameSettings.keyBindForward.pressed
				|| predictedDistance > mc.thePlayer.getDistanceToEntity(target) + 0.08) && onlyForward.isToggled()) {
			timerReset();
			return;
		}

		double tickProgress = playerTicks / positiveTicks.getInput();
		float playerSpeed;

		if (tickProgress < timerboost)
			playerSpeed = positiveTimer.getInputToFloat();
		else if (tickProgress < charged)
			playerSpeed = negativeTimer.getInputToFloat();
		else
			playerSpeed = 1f;

		float speedAdjustment = (float) (playerSpeed >= 0 ? playerSpeed : 1f + positiveTicks.getInput() - playerTicks);
		float adjustedTimerSpeed = Math.max(speedAdjustment, 0f);

		mc.timer.timerSpeed = adjustedTimerSpeed;

		playerTicks--;

	}

	@EventLink
	public void onSendPacket(PacketEvent e) {
		Packet<?> p = e.getPacket();

		if (!e.isSend()) return;
		if (p instanceof C02PacketUseEntity) {
			C02PacketUseEntity wrapper = (C02PacketUseEntity) p;
			if (wrapper.getAction() != C02PacketUseEntity.Action.ATTACK && playerTicks >= 1) {
				timerReset();
				return;
			} else {
				confirmAttack = true;
			}

			double entityDistance = CombatUtil.instance.getDistanceToEntityBox(target);

			cooldownTick++;

			boolean shouldSlowed = cooldownTick >= negativeTick.getInput() && entityDistance <= range.getInput();

			if (shouldSlowed && confirmAttack) {
				confirmAttack = false;
				playerTicks = positiveTicks.getInputToInt();

				confirmKnockback = true;
				cooldownTick = 0;
			} else {
				timerReset();
			}
		}
	}

	@EventLink
	public void onReceivePacket(PacketEvent e) {
		Packet<?> p = e.getPacket();

		if (PlayerUtil.isMoving() && !shouldResetTimer() && (mc.timer.timerSpeed > 1.0 || mc.timer.timerSpeed < 1.0)) {
			if (confirmKnockback) {
				if (p instanceof S12PacketEntityVelocity) {
					S12PacketEntityVelocity wrapper = (S12PacketEntityVelocity) p;
					if (mc.thePlayer.getEntityId() == wrapper.getEntityID() && wrapper.getMotionY() > 0
							&& (wrapper.getMotionX() != 0.0 || wrapper.getMotionZ() != 0.0)) {
						confirmKnockback = false;
						timerReset();
					}
				}
			}

		}

	}

	private boolean shouldResetTimer() {
		return (playerTicks >= 1 || mc.thePlayer.isSpectator() || mc.thePlayer.isDead || mc.thePlayer.isInWater()
				|| mc.thePlayer.isInLava() || mc.thePlayer.isInWeb || mc.thePlayer.isOnLadder()
				|| mc.thePlayer.isRiding());
	}

	private void timerReset() {
		mc.timer.timerSpeed = 1f;
	}
}
