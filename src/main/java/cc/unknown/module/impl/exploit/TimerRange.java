package cc.unknown.module.impl.exploit;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.LivingEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.network.PacketEvent.Type;
import cc.unknown.event.impl.world.WorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.helpers.MathHelper;
import cc.unknown.utils.player.CombatUtil;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.server.S12PacketEntityVelocity;

@Register(name = "TimerRange", category = Category.Exploit)
public class TimerRange extends Module {

	private final SliderValue timerBoost = new SliderValue("Timer Charged", 1.5f, 0.01f, 35f, 0.01);
	private final SliderValue ticks = new SliderValue("Positive Ticks", 10, 1, 20, 1);
	private final SliderValue timerCharged = new SliderValue("Timer Uncharged", 0.45f, 0.05f, 5f, 0.05);
	private final SliderValue range = new SliderValue("Range", 3.5f, 1f, 5f, 0.05);
	private final SliderValue cooldownTick = new SliderValue("Negative Ticks", 10, 1, 50, 1);
	private BooleanValue onlyGround = new BooleanValue("Only Ground", true);
	private BooleanValue ignoreTeams = new BooleanValue("Ignore Teams", true);
	
	private int playerTicks = 0;
	private int downTick = 0;
	private boolean confirmAttack = false;
	private boolean confirmKnockback = false;
	
	public TimerRange() {
		this.registerSetting(ticks, timerBoost, timerCharged, range, cooldownTick, onlyGround);
	}

	@Override
	public void onEnable() {
		timerReset();
	}

	@Override
	public void onDisable() {
		timerReset();
		downTick = 0;
		playerTicks = 0;
		confirmAttack = false;
		confirmKnockback = false;
	}

	@EventLink
	public void onWorld(WorldEvent e) {
		timerReset();
		downTick = 0;
		playerTicks = 0;
		confirmAttack = false;
		confirmKnockback = false;
	}

	@EventLink
	public void onLiving(LivingEvent e) {
		double timerboost = MathHelper.randomDouble(0.5, 0.56);
		double charged = MathHelper.randomDouble(0.75, 0.91);

		if (playerTicks <= 0) {
			timerReset();
			return;
		}
		if (onlyGround.isToggled() && !mc.thePlayer.onGround) {
			timerReset();
			return;
		}
		
		if (CombatUtil.instance.isATeamMate(mc.thePlayer) && ignoreTeams.isToggled()) {
			timerReset();
			return;
		}

		double tickProgress = playerTicks / ticks.getInput();
		float playerSpeed;

		if (tickProgress < timerboost)
			playerSpeed = timerBoost.getInputToFloat();
		else if (tickProgress < charged)
			playerSpeed = timerCharged.getInputToFloat();
		else
			playerSpeed = 1f;

		float speedAdjustment = (float) (playerSpeed >= 0 ? playerSpeed : 1f + ticks.getInput() - playerTicks);
		float adjustedTimerSpeed = Math.max(speedAdjustment, 0f);

		mc.timer.timerSpeed = adjustedTimerSpeed;

		playerTicks--;
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		Packet<?> p = e.getPacket();

		if (e.getType() == Type.RECEIVE) {
			if (PlayerUtil.isMoving() && !shouldResetTimer() && mc.timer.timerSpeed > 1.0 || mc.timer.timerSpeed < 1.0) {
				if (confirmKnockback) {
					if (p instanceof S12PacketEntityVelocity) {
						S12PacketEntityVelocity wrapper = (S12PacketEntityVelocity) p;
						if (mc.thePlayer.getEntityId() == wrapper.getEntityID() && wrapper.motionY > 0 && (wrapper.motionX != 0.0 || wrapper.motionZ != 0.0)) {
							confirmKnockback = false;
							timerReset();
						}
					}
				}
			}
		}
		
		if (e.getType() == Type.SEND) {
			if (p instanceof C02PacketUseEntity) {
				C02PacketUseEntity wrapper = (C02PacketUseEntity) p;
				if (wrapper.getAction() != C02PacketUseEntity.Action.ATTACK) {
					timerReset();
					return;
				} else {
					confirmAttack = true;
				}
				
		        double entityDistance = CombatUtil.instance.getDistanceToEntityBox(mc.thePlayer);

		        downTick++;

		        boolean shouldSlowed = downTick >= cooldownTick.getInput() && entityDistance <= range.getInput();

		        if (shouldSlowed && confirmAttack) {
		            confirmAttack = false;
		            playerTicks = ticks.getInputToInt();

		            confirmKnockback = true;
		            downTick = 0;
		        } else {
		            timerReset();
		        }
		    }
		}
	}

	private boolean shouldResetTimer() {
		return (playerTicks >= 1 || mc.thePlayer.isSpectator() || mc.thePlayer.isDead || mc.thePlayer.isInWater() || mc.thePlayer.isInLava() || mc.thePlayer.isInWeb || mc.thePlayer.isOnLadder() || mc.thePlayer.isRiding());
	}
	
	private void timerReset() {
		mc.timer.timerSpeed = 1f;
	}
}
