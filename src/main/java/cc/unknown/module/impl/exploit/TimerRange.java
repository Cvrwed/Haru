package cc.unknown.module.impl.exploit;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.LivingEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.world.WorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.helpers.MathHelper;
import cc.unknown.utils.player.CombatUtil;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.server.S12PacketEntityVelocity;

@Register(name = "TimerRange", category = Category.Exploit)
public class TimerRange extends Module {

	private SliderValue range = new SliderValue("Range", 3.5f, 1f, 5f, 0.05);
	private SliderValue timerBoost = new SliderValue("Timer Charged", 1.5f, 0.01f, 35f, 0.01);
	private SliderValue ticks = new SliderValue("Positive Ticks", 10, 1, 20, 1);
	private SliderValue timerCharged = new SliderValue("Timer Uncharged", 0.45f, 0.05f, 5f, 0.05);
	private SliderValue cooldownTick = new SliderValue("Negative Ticks", 10, 1, 50, 1);
	private BooleanValue ignoreTeams = new BooleanValue("Ignore Teams", false);
	
	private int playerTicks = 0;
	private int downTick = 0;
	private boolean confirmAttack = false;
	private boolean confirmKnockback = false;
	
	public TimerRange() {
		this.registerSetting(range, ticks, timerBoost, timerCharged, cooldownTick, ignoreTeams);
	}
	
	@EventLink
	public void onGui(ClickGuiEvent e) {
		this.setSuffix("- [" + timerBoost.getInput() + ", " + timerCharged.getInput() + "]");
	}

	@Override
	public void onEnable() {
		timerReset();
	}

	@Override
	public void onDisable() {
	    timerReset();
	    downTick = 0;
	    playerTicks = 0;
	    confirmAttack = false;
	    confirmKnockback = false;
	}

	@EventLink
	public void onWorld(WorldEvent e) {
	    timerReset();
	    downTick = 0;
	    playerTicks = 0;
	    confirmAttack = false;
	    confirmKnockback = false;
	}

	@EventLink
	public void onLiving(LivingEvent e) {
	    double timerboost = MathHelper.randomDouble(0.5, 0.56);
	    double charged = MathHelper.randomDouble(0.75, 0.91);

	    if (playerTicks <= 0) {
	        timerReset();
	        return;
	    }
	    
	    if (CombatUtil.instance.isTeam(mc.thePlayer) && ignoreTeams.isToggled()) {
	        timerReset();
	        return;
	    }

	    double tickProgress = playerTicks / ticks.getInput();
	    float playerSpeed;

	    if (tickProgress < timerboost)
	        playerSpeed = timerBoost.getInputToFloat();
	    else if (tickProgress < charged)
	        playerSpeed = timerCharged.getInputToFloat();
	    else
	        playerSpeed = 1f;

	    float speedAdjustment = (float) (playerSpeed >= 0 ? playerSpeed : 1f + ticks.getInput() - playerTicks);
	    float adjustedTimerSpeed = Math.max(speedAdjustment, 0f);

	    mc.timer.timerSpeed = adjustedTimerSpeed;

	    playerTicks--;
	}

	@EventLink
	public void onPacket(PacketEvent e) {
	    Packet<?> p = e.getPacket();

	    if (e.isReceive()) {
	        if (PlayerUtil.isMoving() && !shouldResetTimer() && (mc.timer.timerSpeed > 1.0 || mc.timer.timerSpeed < 1.0)) {
	            if (confirmKnockback) {
	                if (p instanceof S12PacketEntityVelocity) {
	                    S12PacketEntityVelocity wrapper = (S12PacketEntityVelocity) p;
	                    if (mc.thePlayer.getEntityId() == wrapper.getEntityID() && wrapper.getMotionY() > 0 && (wrapper.getMotionX() != 0.0 || wrapper.getMotionZ() != 0.0)) {
	                        confirmKnockback = false;
	                        timerReset();
	                    }
	                }
	            }
	        }
	    }
	    
	    if (e.isSend()) {
	        if (p instanceof C02PacketUseEntity) {
	            C02PacketUseEntity wrapper = (C02PacketUseEntity) p;
	            if (wrapper.getAction() != C02PacketUseEntity.Action.ATTACK && playerTicks >= 1) {
	                timerReset();
	                return;
	            } else {
	                confirmAttack = true;
	            }
	            
	            double entityDistance = CombatUtil.instance.getDistanceToEntityBox(mc.thePlayer);

	            downTick++;

	            boolean shouldSlowed = downTick >= cooldownTick.getInput() && entityDistance <= range.getInput();

	            if (shouldSlowed && confirmAttack) {
	                confirmAttack = false;
	                playerTicks = ticks.getInputToInt();

	                confirmKnockback = true;
	                downTick = 0;
	            } else {
	                timerReset();
	            }
	        }
	    }
	}

	private boolean shouldResetTimer() {
	    return (playerTicks >= 1 || mc.thePlayer.isSpectator() || mc.thePlayer.isDead || mc.thePlayer.isInWater() || mc.thePlayer.isInLava() || mc.thePlayer.isInWeb || mc.thePlayer.isOnLadder() || mc.thePlayer.isRiding());
	}
	
	private void timerReset() {
		mc.timer.timerSpeed = 1f;
	}
}
