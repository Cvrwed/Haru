package cc.unknown.module.impl.exploit;

import java.util.LinkedList;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.LivingEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.DoubleSliderValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.player.CombatUtil;
import cc.unknown.utils.player.MoveUtil;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.server.S12PacketEntityVelocity;
import net.minecraft.util.MathHelper;

@Register(name = "TimerRange", category = Category.Exploit)
public class TimerRange extends Module {

	private SliderValue range = new SliderValue("Range", 3.5f, 1f, 5f, 0.05);
	private SliderValue positiveTimer = new SliderValue("Positive Timer", 1.5f, 0.01f, 35f, 0.01);
	private SliderValue positiveTicks = new SliderValue("Positive Ticks", 10, 1, 20, 1);
	
	private SliderValue negativeTimer = new SliderValue("Negative Timer", 0.45f, 0.05f, 5f, 0.05);
	private SliderValue negativeTick = new SliderValue("Negative Ticks", 10, 1, 50, 1);
	
	private DoubleSliderValue timerBoost = new DoubleSliderValue("Timer Boost", 0.5, 0.56, 0.1, 1, 1);
	private DoubleSliderValue timerCharged = new DoubleSliderValue("Timer Charged", 0.75, 0.91, 0.1, 1, 1);
	
	private BooleanValue ignoreTeams = new BooleanValue("Ignore Teams", false);
	private BooleanValue onlyGround = new BooleanValue("Only on Ground", false);
	private BooleanValue onlyForward = new BooleanValue("Only Forward", true);
	private BooleanValue notInCombo = new BooleanValue("Not In Combo", true);
	private BooleanValue blink = new BooleanValue("Blink", false);

	private int playerTicks = 0;
	private int cooldownTick = 0;
	private boolean confirmAttack = false;
	private boolean confirmKnockback = false;
	private EntityPlayer target;
	@SuppressWarnings("rawtypes")
	private LinkedList<Packet> outPackets = new LinkedList<Packet>();
	
	public TimerRange() {
		this.registerSetting(range, positiveTimer, positiveTicks, negativeTimer, negativeTick, timerBoost, timerCharged, ignoreTeams,
				onlyGround, onlyForward, notInCombo, blink);
	}
	
	@EventLink
	public void onGui(ClickGuiEvent e) {
		this.setSuffix("- [" + positiveTimer.getInput() + ", " + negativeTimer.getInput() + "]");
	}
	
	@Override
	public void onEnable() {
		timerReset();
	}

	@Override
	public void onDisable() {
		timerReset();
		cooldownTick = 0;
		playerTicks = 0;
		confirmAttack = false;
		confirmKnockback = false;
	}

	@EventLink
	public void onWorld(ChangeWorldEvent e) {
		timerReset();
		cooldownTick = 0;
		playerTicks = 0;
		confirmAttack = false;
		confirmKnockback = false;
	}

	@EventLink
	public void onLiving(LivingEvent e) {
		if (target == null) { return; }
		
		double timerboost = cc.unknown.utils.helpers.MathHelper.randomDouble(timerBoost.getInputMinToFloat(), timerBoost.getInputMaxToFloat());
		double charged = cc.unknown.utils.helpers.MathHelper.randomDouble(timerCharged.getInputMinToFloat(), timerCharged.getInputMaxToFloat());
		double predictX = mc.thePlayer.posX + ((mc.thePlayer.posX - mc.thePlayer.lastTickPosX) * 2);
		double predictZ = mc.thePlayer.posZ + ((mc.thePlayer.posZ - mc.thePlayer.lastTickPosZ) * 2);
		float f = (float) (predictX - target.posX);
		float f1 = (float) (mc.thePlayer.posY - target.posY);
		float f2 = (float) (predictZ - target.posZ);
		double predictedDistance = MathHelper.sqrt_float(f * f + f1 * f1 + f2 * f2);

		if (playerTicks <= 0) {
			timerReset();
			return;
		}

		if (CombatUtil.instance.isTeam(target) && ignoreTeams.isToggled()) {
			timerReset();
			return;
		}
		
		if (mc.thePlayer.getDistance(target.posX, target.posY, target.posZ) < mc.thePlayer.getDistance(0, 0, 0) && notInCombo.isToggled()) {
			timerReset();
			return;
		}
		
		if ((MoveUtil.getSpeed() <= 0.08 || !mc.gameSettings.keyBindForward.pressed || predictedDistance > mc.thePlayer.getDistanceToEntity(target) + 0.08) && onlyForward.isToggled()) {
			timerReset();
			return;
		}

		double tickProgress = playerTicks / positiveTicks.getInput();
		float playerSpeed;

		if (tickProgress < timerboost)
			playerSpeed = positiveTimer.getInputToFloat();
		else if (tickProgress < charged)
			playerSpeed = negativeTimer.getInputToFloat();
		else
			playerSpeed = 1f;

		float speedAdjustment = (float) (playerSpeed >= 0 ? playerSpeed : 1f + positiveTicks.getInput() - playerTicks);
		float adjustedTimerSpeed = Math.max(speedAdjustment, 0f);

		mc.timer.timerSpeed = adjustedTimerSpeed;

		playerTicks--;

	}

	@EventLink
	public void onPacket(PacketEvent e) {
	    Packet<?> p = e.getPacket();

	    if (e.isReceive()) {
	        if (PlayerUtil.isMoving() && !shouldResetTimer() && (mc.timer.timerSpeed > 1.0 || mc.timer.timerSpeed < 1.0)) {
	            if (confirmKnockback) {
	                if (p instanceof S12PacketEntityVelocity) {
	                    S12PacketEntityVelocity wrapper = (S12PacketEntityVelocity) p;
	                    if (mc.thePlayer.getEntityId() == wrapper.getEntityID() && wrapper.getMotionY() > 0 && (wrapper.getMotionX() != 0.0 || wrapper.getMotionZ() != 0.0)) {
	                        confirmKnockback = false;
	                        timerReset();
	                    }
	                }
	            }
	        }
	    }
	    
	    if (e.isSend()) {
	        if (p instanceof C02PacketUseEntity) {
	            C02PacketUseEntity wrapper = (C02PacketUseEntity) p;
	            if (wrapper.getAction() != C02PacketUseEntity.Action.ATTACK && playerTicks >= 1) {
	                timerReset();
	                return;
	            } else {
	                confirmAttack = true;
	            }
	            
	            double entityDistance = CombatUtil.instance.getDistanceToEntityBox(target);

	            cooldownTick++;

	            boolean shouldSlowed = cooldownTick >= negativeTick.getInput() && entityDistance <= range.getInput();

	            if (shouldSlowed && confirmAttack) {
	                confirmAttack = false;
	                playerTicks = positiveTicks.getInputToInt();

	                confirmKnockback = true;
	                cooldownTick = 0;
	            } else {
	                timerReset();
	            }
	        }
	        
			if (p instanceof C03PacketPlayer) {
				if (mc.timer.timerSpeed > 1f && blink.isToggled()) {
					e.setCancelled(true);
					outPackets.add(e.getPacket());
				}
			}
	    }
	}

	private boolean shouldResetTimer() {
	    return (playerTicks >= 1 || mc.thePlayer.isSpectator() || mc.thePlayer.isDead || mc.thePlayer.isInWater() || mc.thePlayer.isInLava() || mc.thePlayer.isInWeb || mc.thePlayer.isOnLadder() || mc.thePlayer.isRiding());
	}
	
	private void timerReset() {
		mc.timer.timerSpeed = 1f;
	}
}
